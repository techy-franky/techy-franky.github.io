<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OWASP Top 10 Write-ups | techy-franky</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: Segoe UI, sans-serif; 
      background: #ffffff; 
      color: #1a1a1a; 
      line-height: 1.6;
    }
    
    .page-header { 
      background: linear-gradient(135deg, #1f6feb, #c53fe6); 
      color: white; 
      padding: 60px 20px; 
      text-align: center; 
    }
    .page-header h1 { font-size: 3rem; margin-bottom: 10px; }
    .page-header p { font-size: 1.2rem; opacity: 0.95; }
    
    .back-nav { 
      background: #f6f8fa; 
      padding: 15px 20px; 
      border-bottom: 1px solid #d0d7de; 
    }
    .back-nav a { 
      color: #0969da; 
      text-decoration: none; 
      font-weight: 600; 
      transition: color 0.2s;
    }
    .back-nav a:hover { color: #0550ae; }
    .back-nav a::before { content: "← "; margin-right: 5px; }
    
    .container { 
      max-width: 1000px; 
      margin: 0 auto; 
      padding: 60px 20px; 
    }
    
    .intro { 
      background: #f6f8fa; 
      padding: 30px; 
      border-radius: 8px; 
      border-left: 4px solid #1f6feb; 
      margin-bottom: 50px; 
    }
    .intro h2 { color: #1f6feb; margin-bottom: 15px; font-size: 1.8rem; }
    .intro h3 { color: #0969da; margin: 20px 0 10px; font-size: 1.3rem; }
    .intro ul { margin-left: 20px; margin-top: 10px; }
    .intro li { margin: 5px 0; }
    
    .writeup { 
      background: #ffffff; 
      border: 1px solid #d0d7de; 
      border-radius: 8px; 
      padding: 40px; 
      margin-bottom: 40px;
    }
    
    .writeup h2 { 
      color: #0969da; 
      font-size: 2rem; 
      margin-bottom: 15px; 
      padding-bottom: 10px;
      border-bottom: 2px solid #d0d7de;
    }
    
    .writeup h3 { 
      color: #1f6feb; 
      font-size: 1.4rem; 
      margin-top: 30px;
      margin-bottom: 15px; 
    }
    
    .writeup h4 { 
      color: #0969da; 
      font-size: 1.1rem; 
      margin-top: 20px;
      margin-bottom: 10px; 
    }
    
    .writeup p { 
      margin-bottom: 15px; 
      color: #24292f; 
    }
    
    .writeup ul, .writeup ol { 
      margin-left: 25px; 
      margin-bottom: 15px; 
    }
    
    .writeup li { 
      margin: 8px 0; 
    }
    
    .tag { 
      display: inline-block; 
      background: #ddf4ff; 
      color: #0969da; 
      padding: 5px 12px; 
      border-radius: 12px; 
      font-size: 0.85rem; 
      margin-right: 8px; 
      margin-bottom: 15px;
    }
    
    .impact-box { 
      background: #fff8c5; 
      border-left: 4px solid #d29922; 
      padding: 15px 20px; 
      margin: 20px 0; 
      border-radius: 4px;
    }
    
    .remediation-box { 
      background: #dafbe1; 
      border-left: 4px solid #1a7f37; 
      padding: 15px 20px; 
      margin: 20px 0; 
      border-radius: 4px;
    }
    
    .key-takeaway { 
      background: #ddf4ff; 
      border-left: 4px solid #0969da; 
      padding: 15px 20px; 
      margin: 20px 0; 
      border-radius: 4px;
      font-style: italic;
    }
    
    footer { 
      background: #f6f8fa; 
      text-align: center; 
      padding: 40px 20px; 
      border-top: 1px solid #d0d7de; 
      color: #656d76; 
      margin-top: 80px;
    }
    footer a { color: #0969da; text-decoration: none; }
    footer a:hover { text-decoration: underline; }
    
    @media (max-width: 768px) {
      .page-header h1 { font-size: 2.2rem; }
      .page-header { padding: 40px 20px; }
      .container { padding: 40px 20px; }
      .writeup { padding: 25px; }
    }
  </style>
</head>
<body>

  <div class="back-nav">
    <a href="index.html">Back to Portfolio</a>
  </div>

  <header class="page-header">
    <h1>OWASP Top 10 (2021)</h1>
    <p>PortSwigger Web Security Academy Labs</p>
  </header>

  <div class="container">
    
    <section class="intro">
      <h2>What Is the OWASP Framework?</h2>
      <p>
        OWASP stands for Open Web Application Security Project—it's this awesome, community-driven nonprofit that's all about making web apps safer. Their "framework" isn't one single thing but a bunch of resources, like the OWASP Top 10, which lists the most critical web risks every few years (updated in 2021). It's got cheat sheets, testing guides, and tools to help devs and pentesters spot and squash vulns. Basically, if you're building or hacking web stuff, OWASP is your go-to bible—free, practical, and crowdsourced from real-world pros.
      </p>
      <p>
        Now, onto those PortSwigger labs. These are hands-on from Burp Suite's Web Security Academy—free, interactive sims of real vulns. I'll map 'em to OWASP Top 10 (A01-A10) and explain casually, like I'm walking you through my own pentest notes. For each, I'll cover the lab gist, how to exploit, impact, and remediation.
      </p>
      
      <h3>Tools Used</h3>
      <ul>
        <li>Burp Suite</li>
        <li>Browser Dev Tools</li>
        <li>ffuf</li>
        <li>sqlmap</li>
        <li>Web Browsers</li>
      </ul>
    </section>

    <article class="writeup">
      <h2>A01: Broken Access Control - Unprotected Admin Functionality</h2>
      
      <div>
        <span class="tag">Broken Access Control</span>
        <span class="tag">A01:2021</span>
        <span class="tag">Admin Panel</span>
      </div>

      <h3>Overview</h3>
      <p>
        Broken Access Control tops the OWASP list because apps often fail to restrict what authenticated users can do or access. In this lab, an admin panel is completely unprotected—anyone can hit it directly.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "Unprotected admin functionality" lab. The app has a blog with user comments, and a hidden <code>/admin</code> endpoint for managing users.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Proxied the site in Burp Suite and crawled it—noticed <code>robots.txt</code> disallowing <code>/admin</code>.</li>
        <li>Navigated to <code>/admin</code> as a low-priv user (wiener)—it loaded no problem, no extra auth.</li>
        <li>Used the panel to delete the target user "carlos."</li>
        <li>Lab solved instantly.</li>
      </ul>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Attackers could delete accounts, escalate privileges, or modify sensitive data—leading to full compromise or data loss.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Implement proper RBAC checks on every sensitive endpoint.</li>
          <li>Avoid relying on obscurity (like hidden paths or robots.txt).</li>
          <li>Use session-based authorization, not just URL hiding.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Obscurity isn't security. Always hunt for hidden endpoints early in recon—robots.txt is a gift sometimes.
      </div>
    </article>

    </article>

    <article class="writeup">
      <h2>A01 Example 2: Broken Access Control - URL-Based Access Control Can Be Circumvented</h2>
      
      <div>
        <span class="tag">Broken Access Control</span>
        <span class="tag">A01:2021</span>
        <span class="tag">IDOR</span>
      </div>

      <h3>Overview</h3>
      <p>
        Another flavor of Broken Access Control: the app "controls" access via URL parameters, but doesn't enforce it server-side.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger: "Access control vulnerabilities" series, specifically the URL-param manipulation one.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Logged in as wiener, accessed my profile via <code>/my-account?id=wiener</code>.</li>
        <li>Intercepted in Burp, changed <code>id</code> to "administrator" or "carlos."</li>
        <li>Request went through—viewed/deleted other users' data.</li>
        <li>Solved by upgrading or deleting the target.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="url based access control.png1" alt="URL Based Access Control - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="url based access control.png2" alt="URL Based Access Control - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="url based access control.png3" alt="URL Based Access Control - Screenshot 3" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Classic IDOR—unauthorized viewing or modification of others' data, potential account takeover.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Always validate object ownership server-side (e.g., check session user matches resource ID).</li>
          <li>Use indirect references (like hashed IDs) if possible.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Never trust client-provided IDs or params for access decisions. Server-side enforcement is non-negotiable.
      </div>
    </article>

    <article class="writeup">
      <h2>A02: Cryptographic Failures - JWT Authentication Bypass via Unverified Signature</h2>
      
      <div>
        <span class="tag">Cryptographic Failures</span>
        <span class="tag">A02:2021</span>
        <span class="tag">JWT</span>
        <span class="tag">Auth Bypass</span>
      </div>

      <h3>Overview</h3>
      <p>
        JWTs rely on cryptographic signatures to ensure the token hasn't been tampered with. In this vuln (part of OWASP A02:2021 Cryptographic Failures), the server completely skips verifying the signature—total rookie mistake. You can forge any token you want.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "JWT authentication bypass via unverified signature" lab. The app uses JWTs in the session cookie for auth, with an admin panel locked behind the "administrator" role.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Logged in as <code>wiener:peter</code> to grab a valid session JWT.</li>
        <li>Proxied traffic in Burp Suite, spotted the session cookie as a JWT in the <code>/my-account</code> request.</li>
        <li>Used Burp's built-in JWT Inspector (or JWT Editor extension) to decode it.</li>
        <li>Changed the "sub" claim from "wiener" to "administrator" (no need to touch the signature since it's not checked).</li>
        <li>Sent the modified token—accessed <code>/admin</code> directly.</li>
        <li>Hit the <code>/admin/delete?username=carlos</code> endpoint to solve the lab.</li>
      </ul>
      <p><em>Optional tools: JWT Editor BApp for fancier handling</em></p>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Full auth bypass—attackers can impersonate any user, including admins. Leads to account takeovers, data theft, or total compromise.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Always verify signatures server-side using a proper library (no skipping!).</li>
          <li>Use strong algorithms like RS256 with secure key management.</li>
          <li>Validate all claims (sub, exp, etc.) and reject invalid tokens.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Signature verification is the core of JWT security—skipping it is like leaving your front door unlocked. This lab hammered home why you can't trust client-provided tokens blindly.
      </div>
    </article>

    <article class="writeup">
      <h2>A03: Injection - SQL Injection Login Bypass</h2>
      
      <div>
        <span class="tag">Injection</span>
        <span class="tag">A03:2021</span>
        <span class="tag">SQL Injection</span>
        <span class="tag">Auth Bypass</span>
      </div>

      <h3>Overview</h3>
      <p>
        SQL Injection (SQLi) is a perennial top risk in OWASP A03:2021 because user inputs get concatenated directly into database queries. In login forms, this often lets attackers bypass authentication entirely—no need for valid credentials.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "SQL injection vulnerability allowing login bypass" lab. The app has a simple username/password login tied to a backend database. Goal: Log in as the "administrator" user without knowing the password.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Accessed the login page and tested the username field with classic SQLi payloads.</li>
        <li>Entered username: <code>administrator'--</code> (the <code>--</code> comments out the rest of the query). Left password blank or random.</li>
        <li>Submitted—boom, logged in as administrator directly.</li>
        <li><strong>Why it works:</strong> The query becomes something like <code>SELECT * FROM users WHERE username='administrator'--' AND password='whatever'</code>, so the password check gets ignored.</li>
        <li>Alternative payloads tested: <code>administrator' OR '1'='1</code> (universal bypass) or <code>administrator'#</code> (MySQL-style comment).</li>
        <li>Lab solved once the admin dashboard loaded.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="sql injection login bypass.png1" alt="SQL Injection Login Bypass - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="sql injection login bypass.png2" alt="SQL Injection Login Bypass - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Unauthenticated access to privileged accounts—attackers can take over admins, exfiltrate data, or pivot deeper. In real apps, this leads to massive breaches (think customer records dumped).
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Use parameterized/prepared statements (e.g., PDO in PHP, ? placeholders).</li>
          <li>Input validation and escaping as a secondary layer (never primary).</li>
          <li>Least privilege DB accounts and WAF rules for extra defense.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Login bypass is the low-hanging fruit of SQLi—always test auth forms first in a pentest. This lab reminded me how one missing quote in the code can hand over the keys to the kingdom. Parameterized queries aren't optional; they're mandatory.
      </div>
    </article>

    <article class="writeup">
      <h2>A03 Example 2: Injection - SQL UNION Attack: Retrieving Data from Other Tables</h2>
      
      <div>
        <span class="tag">Injection</span>
        <span class="tag">A03:2021</span>
        <span class="tag">SQL Injection</span>
        <span class="tag">UNION Attack</span>
      </div>

      <h3>Overview</h3>
      <p>
        SQL Injection with UNION attacks is one of the most powerful flavors of SQLi. It lets you combine your injected query with a legitimate one, pulling data from any table you can reach—as long as the column counts and data types match. Classic way to dump sensitive info like users, passwords, or credit cards.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "SQL injection UNION attack, retrieving data from other tables" lab. The app has a vulnerable "Products" category filter (e.g., <code>/filter?category=Gifts</code>). The goal is to extract the administrator's credentials from a hidden users table and log in.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Tested the category parameter with basic SQLi like <code>' ORDER BY 1--</code> to find the number of columns.</li>
        <li>Kept increasing until error: Turned out to be 2 columns.</li>
        <li>Tested data types with NULL: <code>' UNION SELECT NULL,NULL--</code> worked (both columns accept strings).</li>
        <li>Dumped table names (Oracle DB in this lab): <code>' UNION SELECT table_name, NULL FROM all_tables--</code></li>
        <li>Spotted the <code>users</code> table.</li>
        <li>Dumped column names: <code>' UNION SELECT column_name, NULL FROM all_tab_columns WHERE table_name='USERS'--</code></li>
        <li>Found <code>username</code> and <code>password</code>.</li>
        <li>Extracted the data: <code>' UNION SELECT username, password FROM users--</code></li>
        <li>Got administrator with a hashed password (cracked it offline or just pasted to log in).</li>
        <li>Logged in as administrator—lab solved.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="sql union attack.png1" alt="SQL UNION Attack - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="sql union attack.png2" alt="SQL UNION Attack - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Game over for confidentiality. Attackers can exfiltrate entire databases—user creds, PII, financial data. Often leads to full system compromise when combined with other vulns.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Always use parameterized/prepared statements—UNION attacks die instantly.</li>
          <li>Principle of least privilege: App DB user shouldn't have access to unrelated tables.</li>
          <li>WAF or input filtering as defense-in-depth (but not a silver bullet).</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Column counting and type testing are muscle memory now—start every SQLi with ORDER BY and NULLs. This lab leveled up my data extraction game; dumping arbitrary tables feels like magic when it works. Also, real-world tip: Hashes are often crackable, so grab 'em whenever you can.
      </div>
    </article>

    <article class="writeup">
      <h2>A04: Insecure Design - Excessive Trust in Client-Side Controls</h2>
      
      <div>
        <span class="tag">Insecure Design</span>
        <span class="tag">A04:2021</span>
        <span class="tag">Client-Side</span>
        <span class="tag">Price Manipulation</span>
      </div>

      <h3>Overview</h3>
      <p>
        Apps sometimes enforce critical logic (pricing, quantities, hidden features) entirely in JavaScript or hidden fields, trusting the browser not to tamper. Spoiler: We always tamper.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "Excessive trust in client-side controls" lab. It's an e-commerce site where premium items have sky-high prices to prevent purchase by normal users.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Added a cheap item to cart, then tried adding the expensive "premium" one—price was like $1337.</li>
        <li>Intercepted the POST to <code>/cart</code> in Burp.</li>
        <li>Saw the price was sent as a parameter: <code>"price":133700</code>.</li>
        <li>Changed it to something affordable like <code>"price":100</code>.</li>
        <li>Forwarded the request—item added at my price.</li>
        <li>Proceeded to checkout and "bought" the premium item for peanuts.</li>
        <li>Lab solved.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="excessive trust client side.png1" alt="Excessive Trust in Client-Side Controls - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="excessive trust client side.png2" alt="Excessive Trust in Client-Side Controls - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Financial fraud heaven—discounts, free premium access, negative pricing exploits, etc. Businesses lose money; integrity of the whole shop crumbles.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Validate and enforce all business logic server-side (prices from DB, not client).</li>
          <li>Never send sensitive values that clients can modify.</li>
          <li>Use server-side checks for eligibility, quantities, etc.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Client-side anything is cosmetic only. If it affects money, access, or data, double-check it server-side.
      </div>
    </article>

    <article class="writeup">
      <h2>A05: Security Misconfiguration - CORS Vulnerability with Basic Origin Reflection</h2>
      
      <div>
        <span class="tag">Security Misconfiguration</span>
        <span class="tag">A05:2021</span>
        <span class="tag">CORS</span>
        <span class="tag">Origin Reflection</span>
      </div>

      <h3>Overview</h3>
      <p>
        CORS (Cross-Origin Resource Sharing) is meant to let servers safely share resources across domains, but misconfigs turn it into a data leak vector. OWASP A05 covers this under Security Misconfiguration. In "basic origin reflection," the server blindly echoes back whatever Origin header you send in the Access-Control-Allow-Origin response—meaning any domain can read sensitive responses if credentials are included.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "CORS vulnerability with basic origin reflection" lab. The app has an authenticated user view (<code>/accountDetails</code>) that returns JSON with an API key. It includes <code>Access-Control-Allow-Credentials: true</code>, so cookies are sent with cross-origin requests.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Logged in as <code>wiener:peter</code>, proxied traffic in Burp Suite, and spotted the GET to <code>/accountDetails</code> fetching my API key. Response had <code>Access-Control-Allow-Credentials: true</code>.</li>
        <li>In Burp Repeater, added <code>Origin: https://example.com</code> to the request → server reflected it exactly in <code>Access-Control-Allow-Origin: https://example.com</code>. Boom—reflection confirmed.</li>
        <li>Went to the Exploit Server (built-in in the lab).</li>
        <li>Pasted a simple JS payload from PortSwigger's hints to steal the victim's data.</li>
        <li>Clicked "View exploit" to test—saw my own key logged. Then "Deliver exploit to victim" to send to admin.</li>
        <li>Checked Access log on exploit server → grabbed the admin's API key from the leaked response. Lab solved.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="cors basic origin reflection.png1" alt="CORS Basic Origin Reflection - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="cors basic origin reflection.png2" alt="CORS Basic Origin Reflection - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Attackers trick logged-in users (via phishing/XSS) into visiting a malicious site that steals sensitive data (API keys, session tokens, PII) from the vulnerable app. Since creds are included, it's like handing over the victim's session cross-origin.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Never reflect arbitrary Origins—use a strict allow-list of trusted domains.</li>
          <li>Avoid <code>Access-Control-Allow-Origin: *</code> when credentials are involved (browsers block it anyway).</li>
          <li>Validate Origins server-side against expected values.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> CORS reflection is sneaky because it looks "dynamic" but is actually wide open. Always test Origin reflection in pentests—add random domains and see if it bounces back. This lab showed how a tiny header misconfig can lead to credential exfil without any injection or XSS.
      </div>
    </article>

    <article class="writeup">
      <h2>A06: Vulnerable and Outdated Components - Exploiting Java Deserialization with Apache Commons Collections</h2>
      
      <div>
        <span class="tag">Vulnerable Components</span>
        <span class="tag">A06:2021</span>
        <span class="tag">Deserialization</span>
        <span class="tag">RCE</span>
      </div>

      <h3>Overview</h3>
      <p>
        OWASP A06:2021 (Vulnerable and Outdated Components) covers using old libraries with known exploits. Java deserialization is a classic example: when an app deserializes untrusted data (like session cookies) without proper checks, attackers can inject malicious objects that trigger "gadget chains" in libraries like Apache Commons Collections, leading to remote code execution (RCE).
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "Exploiting Java deserialization with Apache Commons" lab. The app uses a serialization-based session mechanism (cookie stores a serialized Java object) and loads an outdated/vulnerable version of Apache Commons Collections. Goal: Execute a command on the server to delete <code>/home/carlos/morale.txt</code> and solve the lab.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Logged in as <code>wiener:peter</code> in the lab app and proxied traffic with Burp Suite.</li>
        <li>Noticed the session cookie starts with <code>rO0AB...</code> (classic base64-encoded Java serialized object—starts with <code>aced</code> in hex).</li>
        <li>Confirmed deserialization vuln: The app deserializes this cookie without safe checks.</li>
        <li>Used ysoserial (the go-to tool for gadget chains): Downloaded <code>ysoserial-all.jar</code>.</li>
        <li>Generated payload targeting CommonsCollections4 (matches the lab's vulnerable lib).</li>
        <li>For Java ≤15: <code>java -jar ysoserial-all.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64 -w 0</code></li>
        <li>Copied the long base64 string output.</li>
        <li>In Burp Repeater (on any request that sends the session cookie), replaced the original session value with the new malicious one.</li>
        <li>URL-encoded the entire cookie value (right-click > Convert selection > URL > URL Encode All Characters).</li>
        <li>Sent the request—server deserialized it, triggered the gadget chain, executed <code>rm /home/carlos/morale.txt</code>. Lab solved (even though you get a deserialization error in response—the command ran!).</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="java deserialization.png1" alt="Java Deserialization - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="java deserialization.png2" alt="Java Deserialization - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Remote code execution on the server—attackers can run arbitrary commands (shell, reverse shell, data exfil, ransomware, etc.). In real apps, this often leads to full server compromise, especially in microservices or legacy Java backends.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Avoid deserializing untrusted data entirely (use JSON/XML instead).</li>
          <li>If you must: Use look-ahead deserialization (e.g., ObjectInputFilter in Java 9+), allow-lists for classes, or libraries like NotSoSerial.</li>
          <li>Keep components updated—patch Apache Commons Collections (newer versions block gadget chains) or remove vulnerable ones.</li>
          <li>Runtime protections: WAF rules for serialized patterns, container isolation.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> This lab is awesome for showing how "just using a library" can bite you hard. Gadget chains turn innocent deserialization into RCE without writing custom exploits—ysoserial makes it scarily easy. Always hunt for serialized blobs (base64 starting with rO0AB/aced) in cookies, headers, or params.
      </div>
    </article>

    <article class="writeup">
      <h2>A07: Identification and Authentication Failures - Username Enumeration via Different Responses</h2>
      
      <div>
        <span class="tag">Auth Failures</span>
        <span class="tag">A07:2021</span>
        <span class="tag">Username Enumeration</span>
        <span class="tag">Brute Force</span>
      </div>

      <h3>Overview</h3>
      <p>
        OWASP A07:2021 (Identification and Authentication Failures) includes issues where apps leak info about valid users through inconsistent responses. In this case, the login error messages differ slightly depending on whether the username exists—making it easy to enumerate valid accounts.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "Username enumeration via different responses" lab. The app has a standard login form. Goal: Identify a valid username from a provided wordlist, brute-force its password from another list, then log in and access the account page.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Proxied the login POST request in Burp Suite (usually to <code>/login</code>).</li>
        <li>Used Burp Intruder: Loaded a wordlist of candidate usernames (provided in the lab) as payload position 1, fixed a dummy password like "password".</li>
        <li>Attacked → Analyzed responses in Intruder table: Most gave "Invalid username" (short response), but one username returned a longer/different message like "Incorrect password" (or subtle length diff ~10-20 bytes).</li>
        <li>Noted the valid username (e.g., "wiener" or whatever the lab gives).</li>
        <li>New Intruder attack: Fixed the valid username, loaded password wordlist as payload position 2.</li>
        <li>Attacked → Looked for the response without the error message (or 302 redirect instead of 200 with error).</li>
        <li>Used the winning username + password combo to log in → accessed <code>/my-account</code>. Lab solved.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="username enumeration.png1" alt="Username Enumeration - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="username enumeration.png2" alt="Username Enumeration - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Attackers build a list of valid users quickly, then target them with credential stuffing, brute-force, or phishing. Makes other auth attacks way more effective.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Use generic error messages ("Invalid username or password") for both cases.</li>
          <li>Add random delays or fixed response lengths to hide timing/length diffs.</li>
          <li>Rate-limit login attempts globally or per IP.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Even tiny response differences (length, wording, timing) can leak info. Always normalize login responses in code. This lab is great for showing why "security through obscurity" fails—Burp Intruder makes enum trivial.
      </div>
    </article>

    <article class="writeup">
      <h2>A08: Software and Data Integrity Failures - Web Cache Poisoning with Unkeyed Header</h2>
      
      <div>
        <span class="tag">Integrity Failures</span>
        <span class="tag">A08:2021</span>
        <span class="tag">Cache Poisoning</span>
        <span class="tag">XSS</span>
      </div>

      <h3>Overview</h3>
      <p>
        A08 covers failures in integrity checks, including cache poisoning where unkeyed inputs (not part of the cache key) let attackers inject malicious content that gets cached and served to everyone.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "Web cache poisoning with an unkeyed header" lab. The app reflects an unkeyed header (like X-Forwarded-Host or similar) into page content without proper sanitization. Goal: Poison the cache so visiting users get an XSS payload (alert()).
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Proxied the homepage in Burp Suite.</li>
        <li>Used Param Miner extension (or manual guessing) to find unkeyed headers—lab often uses something like <code>X-Forwarded-Host</code>.</li>
        <li>In Repeater: Added a malicious header, e.g., <code>X-Forwarded-Host: attacker.com</code>, and injected XSS in a reflected spot (like <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> via the poisoned import or reflection).</li>
        <li>Sent request, saw <code>X-Cache: miss</code> → then replayed until <code>X-Cache: hit</code> (cache poisoned).</li>
        <li>Used a cache-buster (e.g., <code>?buster=123</code>) to test your own view without poisoning further.</li>
        <li>Loaded the normal homepage in browser → alert() popped (victim simulation). Kept re-poisoning if needed until lab solved.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="cache poisoning.png1" alt="Web Cache Poisoning - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="cache poisoning.png2" alt="Web Cache Poisoning - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Mass XSS or defacement—poisoned responses served to all users hitting the cached page. Can steal cookies, phish, or deliver malware to thousands.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Include all user-controlled inputs that affect response in the cache key.</li>
          <li>Sanitize/escape reflected headers.</li>
          <li>Use short cache TTLs or Vary: on relevant headers.</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Caches are dumb—they key on what you tell them. Unkeyed headers are a huge red flag. This lab shows how obscure headers (X-Forwarded-*) can turn a cache into an attack delivery system. Super relevant for CDNs and modern apps.
      </div>
    </article>

    <article class="writeup">
      <h2>A09: Security Logging and Monitoring Failures</h2>
      
      <div>
        <span class="tag">Logging & Monitoring</span>
        <span class="tag">A09:2021</span>
        <span class="tag">Security Operations</span>
      </div>

      <h3>Overview</h3>
      <p>
        This category is about insufficient logging, monitoring, or alerting, so attacks go undetected. No dedicated PortSwigger lab here, but in practice: Enable detailed logs (auth failures, input anomalies), use SIEM tools, and alert on suspicious patterns. It's often the reason breaches last weeks/months. Easy to overlook, but critical for incident response.
      </p>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Awareness of the full OWASP Top 10—even the non-exploitable ones matter for mature security programs. Logging and monitoring are your last line of defense when prevention fails.
      </div>
    </article>

    <article class="writeup">
      <h2>A10: Server-Side Request Forgery (SSRF) - SSRF with Input-Based Filters</h2>
      
      <div>
        <span class="tag">SSRF</span>
        <span class="tag">A10:2021</span>
        <span class="tag">Filter Bypass</span>
      </div>

      <h3>Overview</h3>
      <p>
        A10: SSRF lets attackers make the server request unintended resources. Here, input-based filters (blacklists/whitelists) block obvious localhost/127.0.0.1, but can be bypassed with tricks.
      </p>

      <h3>Lab Environment</h3>
      <p>
        PortSwigger Web Security Academy: "SSRF with input-based filters" (likely the blacklist-based one). The app has a stock checker that fetches URLs, but filters block localhost and /admin. Goal: Bypass to hit <code>http://localhost/admin</code> and delete user carlos.
      </p>

      <h3>Discovery & Exploitation</h3>
      <ul>
        <li>Proxied the stock check request (usually POST with <code>url=</code> param).</li>
        <li>Tested basic SSRF: <code>url=http://localhost/admin</code> → blocked by filter.</li>
        <li>Bypassed blacklist: Tried variations like:
          <ul>
            <li><code>http://127.0.0.1.xip.io</code> (resolves to 127.0.0.1)</li>
            <li><code>http://127.1</code> (octal/shortened IP)</li>
            <li><code>http://2130706433</code> (decimal IP for 127.0.0.1)</li>
            <li><code>http://[::1]</code> (IPv6 localhost)</li>
            <li><code>http://localhost%23@evil.com/</code> (URL parsing tricks)</li>
          </ul>
        </li>
        <li>Common winner in labs: <code>http://127.0.0.1/admin</code> (sometimes filter misses case or path) or burpcollaborator for out-of-band confirmation.</li>
        <li>Once bypassed, requested <code>http://localhost/admin/delete?username=carlos</code>.</li>
        <li>Server fetched it → user deleted, lab solved.</li>
      </ul>

      <h3>Screenshots</h3>
      <div style="margin: 20px 0;">
        <img src="ssrf filter bypass.png1" alt="SSRF Filter Bypass - Screenshot 1" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px; margin-bottom: 15px;">
        <img src="ssrf filter bypass.png2" alt="SSRF Filter Bypass - Screenshot 2" style="max-width: 100%; border: 1px solid #d0d7de; border-radius: 6px;">
      </div>

      <div class="impact-box">
        <h4>Impact</h4>
        <p>
          Internal network access—metadata exfil (cloud IMDS), port scanning, or pivoting to other services. Can lead to RCE or data theft from internal systems.
        </p>
      </div>

      <div class="remediation-box">
        <h4>Remediation</h4>
        <ul>
          <li>Use strict whitelists (not blacklists).</li>
          <li>Validate scheme/host/port fully.</li>
          <li>Disable unnecessary protocols (no file://, dict://, etc.).</li>
          <li>Use network-level controls (firewalls).</li>
        </ul>
      </div>

      <div class="key-takeaway">
        <strong>Key Takeaway:</strong> Blacklists always lose—attackers have endless bypasses (IP formats, encodings, redirects). Whitelists or no SSRF at all is safer. This lab is perfect for showing filter evasion creativity.
      </div>
    </article>

  </div>

  <footer>
    <p>© 2025 techy-franky | <a href="index.html">Back to Portfolio</a></p>
  </footer>

</body>
</html>
